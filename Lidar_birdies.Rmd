---
title: "Lidar Birdies"
author: "Mike Allen"
date: "11/10/2020"
output: html_document
---

```{r}
library(raster)
library(rgdal)
library(sp)
library(sf)
library(tidyverse)
library(lidR)
library(tmap)
library(tmaptools)
library(lubridate)
```
# Read in shapefiles
```{r}
# read in duke field borders
duke <- 
   read_sf("data/duke_GL_pred_areas.shp") %>%
   st_transform(crs = 32618)
```
# Read in and check 2018 lidar files
Note: reprojected from NJ state plane (NAD83) into UTM zone 18 in LAStools in QGIS.
source for all lidR code used: http://www.wvview.org/spatial_analytics/lidar/_site/index.html#lidar
```{r}
# las_cat18 <- readLAScatalog("data/lidar2018/")
# projection(las_cat18) <- crs(6527) # state plane nad83(2011) in US feet
# summary(las_cat18)
# 
# lascheck(las_cat18)
```
# Read in and check 2008 lidar files
Note: reprojected from long/lat into UTM zone 18 in LAStools in QGIS.
source for code: http://www.wvview.org/spatial_analytics/lidar/_site/index.html#lidar
```{r}
#las_cat <- readLAScatalog("data/lidar2008/")
#projection(las_cat) <- crs(32618) # utm
#summary(las_cat)

#lascheck(las_cat)
```
# Choose scale to process 2018 lidar files
```{r}
# opt_chunk_size(las_cat18) <- 5100
# plot(las_cat18, chunk_pattern = TRUE)
# 
# opt_chunk_buffer(las_cat18) <- 100
# plot(las_cat18, chunk_pattern = TRUE)
```
# Choose scale to process 2008 lidar files
```{r}
#opt_chunk_size(las_cat) <- 2000
#plot(las_cat, chunk_pattern = TRUE)

#opt_chunk_buffer(las_cat) <- 40
#plot(las_cat, chunk_pattern = TRUE)
```
# View summary of 2018 lidar files
```{r}
# summary(las_cat18)
```
# View summary of 2008 lidar files
```{r}
#summary(las_cat)
```
# Create & view 2008 digital terrain models ("bare earth")
```{r}
# opt_output_files(las_cat) <- "data/dtm2008/dtm_{XLEFT}_{YBOTTOM}"
# dtm2008 <-
#    grid_terrain(las_cat,
#                 res = 1,
#                 knnidw(k = 10, p = 2),
#                 keep_lowest = FALSE) %>%
#    crop(y = (extent(duke) + c(-250, 250, -250, 250)))
# crs(dtm2008) <- crs(duke)

dtm2008 <- 
  raster("data/dtm2008.tif") # to save time

slope <- terrain(dtm2008, opt='slope')
aspect <- terrain(dtm2008, opt='aspect')
hs <- hillShade(slope, aspect, angle=45, direction=315)

tm_shape(hs)+
tm_raster(style= "cont", palette=get_brewer_pal("Greys", plot=FALSE))+
tm_layout(legend.outside = TRUE)
```
# Create & view 2018 digital terrain models ("bare earth")
```{r}
# opt_output_files(las_cat18) <- "data/dtm2018/dtm_{XLEFT}_{YBOTTOM}"
# dtm2018_step1 <-
#    grid_terrain(las_cat18,
#                 res = 3.28084,
#                 knnidw(k = 10, p = 2),
#                 keep_lowest = FALSE)
# 
# crs(dtm2018_step1) <-
#    CRS("+init=epsg:6527") # nj state plane nad83 (2011), grs80 in US feet
# 
# dtm2018 <-
#    projectRaster(from = dtm2018_step1,
#                  to = dtm2008) 
#
# dtm2018 <- dtm2018 / 3.28084

dtm2018 <-
   raster("data/dtm2018.tif") # to save time

slope <- terrain(dtm2018, opt='slope')
aspect <- terrain(dtm2018, opt='aspect')
hs <- hillShade(slope, aspect, angle=45, direction=315)

tm_shape(hs)+
tm_raster(style= "cont", palette=get_brewer_pal("Greys", plot=FALSE))+
tm_layout(legend.outside = TRUE)
```

# Create 2008 digital surface models (i.e., "bare earth + canopy height")
```{r}
# opt_output_files(las_cat) <- "data/dsm2008/dsm_{XLEFT}_{YBOTTOM}"
# dsm2008 <-
#    grid_canopy(las_cat, res = 1, pitfree(c(0, 2, 5, 10, 15), c(0, 1))) %>%
#    crop(extent(duke) + c(-250, 250, -250, 250))
# crs(dsm2008) <- crs(duke)

dsm2008 <- 
   raster("data/dsm2008.tif") # to save time

slope <- terrain(dsm2008, opt='slope')
aspect <- terrain(dsm2008, opt='aspect')
hs <- hillShade(slope, aspect, angle=45, direction=315)

tm_shape(hs)+
tm_raster(style= "cont", palette=get_brewer_pal("Greys", plot=FALSE))+
tm_layout(legend.outside = TRUE)
```
# Create 2018 digital surface models (i.e., "bare earth + canopy height")
```{r}
 # opt_output_files(las_cat18) <- "data/dsm2018/dsm_{XLEFT}_{YBOTTOM}"
 # dsm2018_step1 <-
 #    grid_canopy(las_cat18, res = 3.28084, pitfree(c(0, 2, 5, 10, 15), c(0, 1))) 
 # 
 # dsm2018_step1[dsm2018_step1>300] <- NA # remove elevation outliers
 # 
 # crs(dsm2018_step1) <-
 #    CRS("+init=epsg:6527") # nj state plane nad83 (2011), grs80 in US feet
 # 
 # dsm2018 <-
 #    projectRaster(from = dsm2018_step1,
 #                  to = dsm2008) 
 # 
 # dsm2018 <- dsm2018 / 3.28084
 
dsm2018 <- 
   raster("data/dsm2018.tif") # to save time

slope <- terrain(dsm2018, opt='slope')
aspect <- terrain(dsm2018, opt='aspect')
hs <- hillShade(slope, aspect, angle=45, direction=315)

tm_shape(hs)+
tm_raster(style= "cont", palette=get_brewer_pal("Greys", plot=FALSE))+
tm_layout(legend.outside = TRUE)
```
# Remove a tree line that was not present during the bird surveys
```{r}
# remove a tree line that was removed in 2018 after lidar but before survey
# make 4 boxes to "cut down" the tree line
boxes2018 = rbind.data.frame(
   expand.grid(
      y = c(7470:7610),
      x = c(8635:8681),
      new = 30.5
   ),
   expand.grid(
      y = c(7408:7465),
      x = c(8627:8661),
      new = 29.5
   ),
   expand.grid(
      y = c(7352:7410),
      x = c(8619:8649),
      new = 27.5
   ),
   expand.grid(
      y = c(7302:7354),
      x = c(8616:8646),
      new = 25.5
   )
) %>%
   group_by(y, x) %>%
   summarise(new = mean(new)) %>%
   ungroup() %>%
   mutate(y = format(y + 4480000.5, digits = 8),
          x = x + 520000.5)

dsm2018.newVals_step1 <- dsm2018
dsm2018.newVals_step1[is.na(dsm2018.newVals_step1)] <- 0
dsm2018.newVals <- rasterToPoints(dsm2018.newVals_step1) %>%
   as.data.frame(headers = F) %>%
   mutate(y = as.character(y)) %>%
   left_join(boxes2018, by = c("x", "y")) %>%
   mutate(dsm2018 = case_when(is.na(new) == T ~ dsm2018,
                              TRUE ~ new),
          y = as.numeric(y)) %>%
   dplyr::select(-new)

# make the new raster with treelines and artifacts removed
dsm2018.fix <- dsm2018 %>%
   setValues(dsm2018.newVals[,3])
# writeRaster(dsm2018.fix, "data/dsm2018.fix.tif", overwrite = T)
```
# Remove powerlines to test if occupancy model fits better with or without this
If without, then they are not likely reacting strongly to the wires
```{r}
boxes2018.nowires = rbind.data.frame(
   expand.grid(
      y = c(8799:8929),
      x = c(9301:9358),
      new = 3
   ),
   expand.grid(
      y = c(8619:8800),
      x = c(9292:9332),
      new = 3
   ),
   expand.grid(
      y = c(8438:8623),
      x = c(9282:9315),
      new = 3 
   ),
   expand.grid(
      y = c(8260:8442),
      x = c(9272:9309),
      new = 3
   ),
   expand.grid(
      y = c(8130:8263),
      x = c(9264:9296),
      new = 3
   ),
   expand.grid(
      y = c(7987:8132),
      x = c(9257:9286),
      new = 3
   ),
   expand.grid(
      y = c(7853:7992),
      x = c(9249:9282),
      new = 3 
   ),   
   expand.grid(
      y = c(7702:7861),
      x = c(9242:9314),
      new = 3 
   ),
   expand.grid(
      y = c(7684:7707),
      x = c(9276:9336),
      new = 3
   )
) %>%
   group_by(y, x) %>%
   summarise(new = mean(new)) %>%
   ungroup() %>%
   mutate(y = format(y + 4480000.5, digits = 8),
          x = x + 520000.5)

dsm2018.nowires.newVals <- rasterToPoints(dsm2018.fix) %>%
   as.data.frame(headers = F) %>%
   mutate(y = as.character(y)) %>%
   left_join(boxes2018.nowires, by = c("x", "y")) %>%
   mutate(dsm2018 = case_when(is.na(new) == T ~ dsm2018,
                              TRUE ~ new),
          y = as.numeric(y)) %>%
   dplyr::select(-new)

# make the new raster with treelines and artifacts removed
dsm2018.nowires <- dsm2018.fix %>%
   setValues(dsm2018.nowires.newVals[,3])
```
# Remove all tree lines for scenario evaluation
To see predicted effect on occupancy
```{r}
boxes2018.notrees = rbind.data.frame(
   expand.grid( # SW tree line
      y = c(7320:7676),
      x = c(8483:8677),
      new = 3
   ),
   expand.grid( # SE tree line
      y = c(7545:7682),
      x = c(8698:8853),
      new = 3
   ),
   expand.grid( # N tree line
      y = c(8356:8702),
      x = c(8642:8805),
      new = 3
   )
) %>%
   group_by(y, x) %>%
   summarise(new = mean(new)) %>%
   ungroup() %>%
   mutate(y = format(y + 4480000.5, digits = 8),
          x = x + 520000.5)

dsm2018.notrees.newVals <- rasterToPoints(dsm2018.fix) %>%
   as.data.frame(headers = F) %>%
   mutate(y = as.character(y)) %>%
   left_join(boxes2018.notrees, by = c("x", "y")) %>%
   mutate(dsm2018 = case_when(is.na(new) == T ~ dsm2018,
                              TRUE ~ new),
          y = as.numeric(y)) %>%
   dplyr::select(-new)

# make the new raster with treelines and artifacts removed
dsm2018.notrees <- dsm2018.fix %>%
   setValues(dsm2018.notrees.newVals[,3])
```
# Remove just the SW tree line for scenario evaluation
To see predicted effect on occupancy
```{r}
boxes2018.noSW = rbind.data.frame(
   expand.grid( # SW tree line
      y = c(7320:7676),
      x = c(8483:8677),
      new = 3
   )
) %>%
   group_by(y, x) %>%
   summarise(new = mean(new)) %>%
   ungroup() %>%
   mutate(y = format(y + 4480000.5, digits = 8),
          x = x + 520000.5)

dsm2018.noSW.newVals <- rasterToPoints(dsm2018.fix) %>%
   as.data.frame(headers = F) %>%
   mutate(y = as.character(y)) %>%
   left_join(boxes2018.noSW, by = c("x", "y")) %>%
   mutate(dsm2018 = case_when(is.na(new) == T ~ dsm2018,
                              TRUE ~ new),
          y = as.numeric(y)) %>%
   dplyr::select(-new)

# make the new raster with treelines and artifacts removed
dsm2018.noSW <- dsm2018.fix %>%
   setValues(dsm2018.noSW.newVals[,3])
```
# Remove just the SE tree line for scenario evaluation
To see predicted effect on occupancy
```{r}
boxes2018.noSE = rbind.data.frame(
   expand.grid( # SE tree line
      y = c(7545:7682),
      x = c(8698:8853),
      new = 3
   )
) %>%
   group_by(y, x) %>%
   summarise(new = mean(new)) %>%
   ungroup() %>%
   mutate(y = format(y + 4480000.5, digits = 8),
          x = x + 520000.5)

dsm2018.noSE.newVals <- rasterToPoints(dsm2018.fix) %>%
   as.data.frame(headers = F) %>%
   mutate(y = as.character(y)) %>%
   left_join(boxes2018.noSE, by = c("x", "y")) %>%
   mutate(dsm2018 = case_when(is.na(new) == T ~ dsm2018,
                              TRUE ~ new),
          y = as.numeric(y)) %>%
   dplyr::select(-new)

# make the new raster with treelines and artifacts removed
dsm2018.noSE <- dsm2018.fix %>%
   setValues(dsm2018.noSE.newVals[,3])
```
# Remove just the N tree line for scenario evaluation
To see predicted effect on occupancy
```{r}
boxes2018.noN = rbind.data.frame(
   expand.grid( # N tree line
      y = c(8356:8702),
      x = c(8642:8805),
      new = 3
   )
) %>%
   group_by(y, x) %>%
   summarise(new = mean(new)) %>%
   ungroup() %>%
   mutate(y = format(y + 4480000.5, digits = 8),
          x = x + 520000.5)

dsm2018.noN.newVals <- rasterToPoints(dsm2018.fix) %>%
   as.data.frame(headers = F) %>%
   mutate(y = as.character(y)) %>%
   left_join(boxes2018.noN, by = c("x", "y")) %>%
   mutate(dsm2018 = case_when(is.na(new) == T ~ dsm2018,
                              TRUE ~ new),
          y = as.numeric(y)) %>%
   dplyr::select(-new)

# make the new raster with treelines and artifacts removed
dsm2018.noN <- dsm2018.fix %>%
   setValues(dsm2018.noN.newVals[,3])
```

# Make the final rasters for horizon analysis
These are the corrected DSMs "flooded" to the height of the DTM plus 1.61 meters (human eye height).
```{r}
dtm2008_plus_eye <- dtm2008 + 1.61 # the height of Mike's eyes
dtm2018_plus_eye <- dtm2018 + 1.61 # the height of Mike's eyes

dsm.eye2008 <- max(dtm2008_plus_eye, dsm2008)
dsm.eye2018 <- max(dtm2018_plus_eye, dsm2018)
dsm.eye2018.fix <- max(dtm2018_plus_eye, dsm2018.fix)
dsm.eye2018.nowires <- max(dtm2018_plus_eye, dsm2018.nowires)
dsm.eye2018.notrees <- max(dtm2018_plus_eye, dsm2018.notrees)
dsm.eye2018.noSW <- max(dtm2018_plus_eye, dsm2018.noSW)
dsm.eye2018.noSE <- max(dtm2018_plus_eye, dsm2018.noSE)
dsm.eye2018.noN <- max(dtm2018_plus_eye, dsm2018.noN)

#writeRaster(dsm.eye2008, "data/dsm.eye2008.tif", overwrite = T)
#writeRaster(dsm.eye2018, "data/dsm.eye2018.tif", overwrite = T)
#writeRaster(dsm.eye2018.fix, "data/dsm.eye2018.fix.tif", overwrite = T)
#writeRaster(dsm.eye2018.nowires, "data/dsm.eye2018.nowires.tif", overwrite = T)
#writeRaster(dsm.eye2018.notrees, "data/dsm.eye2018.notrees.tif", overwrite = T)
#writeRaster(dsm.eye2018.noSW, "data/dsm.eye2018.noSW.tif", overwrite = T)
#writeRaster(dsm.eye2018.noSE, "data/dsm.eye2018.noSE.tif", overwrite = T)
#writeRaster(dsm.eye2018.noN, "data/dsm.eye2018.noN.tif", overwrite = T)
```

# Map mean horizon heights from all angles
Note: I used GRASS GUI (r.horizon & r.series functions) to make the horizon rasters. Mean or max of 72 height-of-horizon measurements around each cell.
```{r}
horizon2018_mean <- raster("data/horizon2018fix_mean_5.tif") 
horizon2018_max <- raster("data/horizon2018fix_max_5.tif") 

plot((90-mask(horizon2018_mean, duke)), col = viridis::inferno(256)); plot((90-mask(horizon2018_max, duke)), col = viridis::inferno(256))

```

# Formatting bird data for occupancy modelling
```{r}
d = read.csv("data/dukebirds2018-2019.QCed.2019-11-20.csv") %>%
   dplyr::select(
      obs,
      date,
      year,
      fld,
      per,
      pt,
      start,
      sp,
      num,
      dist,
      az,
      detect,
      sex,
      voc,
      lon = pt.lon,
      lat = pt.lat
   ) %>%
   st_as_sf(coords = c("lon", "lat"), crs = 4326) %>%
   st_transform(crs = crs(dtm2008)) %>%
   mutate(r.date = mdy(date)) %>%
   mutate(ord = yday(r.date)) %>%
   mutate(month = month(r.date)) %>%
   mutate(
      dist3 = ifelse(sp == "GRSP" & is.na(dist) == T, 55, dist),
      dist4 = ifelse(sp == "BOBO" & is.na(dist) == T, 56, dist3),
      dist5 = ifelse(sp == "EAME" & is.na(dist) == T, 77, dist4),
      dist = ifelse(sp == "RWBL" & is.na(dist) == T, 57, dist5),
      az = ifelse(is.na(az) == T, runif(1, 0, 360), az)
   ) %>%
   select(-dist3,-dist4,-dist5) %>%
   mutate(
      hour = case_when(substr(start, 1, 1) == 1 ~ 10,
                       TRUE ~ as.numeric(substr(start, 1, 1))),
      min = case_when(substr(start, 1, 1) == 1 ~ 0,
                      TRUE ~ as.numeric(substr(start, 3, 4))),
      dtime = hour + min / 60
   )
#### NOTE RE MISSING DISTANCE DATA ####
# several GRSP and some other "hard to spot" species had dist and / or az left blank
# all of these records were believed to be within 100 m
# for mapping purposes, we will assume an average distance (by species) and random azimuth

pt.per.list <- d %>%
   as.data.frame() %>%
   dplyr::select(year, pt, per) %>%
   distinct() %>%
   arrange(year, pt, per)

d.occ.long <- d %>%
   as.data.frame() %>%
   mutate(pres = case_when(num>0 & dist<75 ~ 1,
                           TRUE ~ 0)) %>%
   dplyr::select(year, pt, per, sp, pres, ord, dtime) %>%
   group_by(year, pt, per, sp, ord, dtime) %>%
   summarise(pres = max(pres)) %>%
   ungroup()
   
g.occ <-
   d.occ.long %>%
   filter(sp == "GRSP") %>%
   right_join(pt.per.list, by = c("year", "pt", "per")) %>%
   mutate(pres = case_when(is.na(sp)==T ~ 0,
                           TRUE ~ pres)) %>%
   arrange(year, pt, per) %>%
   mutate(survey = case_when(per %in% c(1,2) ~ 1,
                             per %in% c(3,4) ~ 2, 
                             per %in% c(5,6) ~ 3,
                             per %in% c(7,8) ~ 4)) %>%
   pivot_wider(id = c(year, pt, survey), names_from = survey, values_from = pres)

b.occ <-
   d.occ.long %>%
   filter(sp == "BOBO") %>%
   right_join(pt.per.list, by = c("year", "pt", "per")) %>%
   mutate(pres = case_when(is.na(sp)==T ~ 0,
                           TRUE ~ pres)) %>%
   arrange(year, pt, per) %>%
   mutate(survey = case_when(per %in% c(1,2) ~ 1,
                             per %in% c(3,4) ~ 2, 
                             per %in% c(5,6) ~ 3,
                             per %in% c(7,8) ~ 4)) %>%
   pivot_wider(id = c(year, pt, survey), names_from = survey, values_from = pres)

e.occ <-
   d.occ.long %>%
   filter(sp == "EAME") %>%
   right_join(pt.per.list, by = c("year", "pt", "per")) %>%
   mutate(pres = case_when(is.na(sp)==T ~ 0,
                           TRUE ~ pres)) %>%
   arrange(year, pt, per) %>%
   mutate(survey = case_when(per %in% c(1,2) ~ 1,
                             per %in% c(3,4) ~ 2, 
                             per %in% c(5,6) ~ 3,
                             per %in% c(7,8) ~ 4)) %>%
   pivot_wider(id = c(year, pt, survey), names_from = survey, values_from = pres)

survey.ord <-
   d.occ.long %>%
   distinct(year, pt, per, ord) %>%
   arrange(year, pt, per) %>%
   mutate(survey = case_when(per %in% c(1,2) ~ 1,
                             per %in% c(3,4) ~ 2, 
                             per %in% c(5,6) ~ 3,
                             per %in% c(7,8) ~ 4)) %>%
   pivot_wider(id = c(year, pt, survey), names_from = survey, values_from = ord)

survey.dtime <-
   d.occ.long %>%
   distinct(year, pt, per, dtime) %>%
   arrange(year, pt, per) %>%
   mutate(dtime = case_when(is.na(dtime) ~ 7.7,
                            TRUE ~ as.numeric(dtime))) %>%
   mutate(survey = case_when(per %in% c(1,2) ~ 1,
                             per %in% c(3,4) ~ 2, 
                             per %in% c(5,6) ~ 3,
                             per %in% c(7,8) ~ 4)) %>%
   pivot_wider(id = c(year, pt, survey), names_from = survey, values_from = dtime)

d.extract <- d %>% 
   dplyr::select(pt) %>%
   distinct(pt) 


site.cov <- cbind.data.frame(pt = as.data.frame(d.extract)$pt, 
                             mean = 90-raster::extract(horizon2018_mean, d.extract),
                             max = 90-raster::extract(horizon2018_max, d.extract)) %>%
   left_join(g.occ, by = "pt") %>%
   arrange(year, pt) %>%
   dplyr::select(year, pt, mean, max)
```
# Create unmarked data.frame for GRSP, static occupancy, 2018 (unmarked)
```{r}
library(unmarked)
g.umf <- unmarkedFrameOccu(
   y = as.matrix(filter(g.occ, year == "year 1")[, 3:6]),
   # Pres/Abs measurements
   siteCovs = filter(site.cov, year == "year 1"),
   # site-specific covs.
   obsCovs = list(ord = (as.matrix(filter(
      survey.ord, year == "year 1"
   )[, 3:6])/10), dtime = (as.matrix(filter(
      survey.dtime, year == "year 1"
   )[, 3:6])/10))
)         # obs-specific covs.
summary(g.umf)
```
# Select best detection model using AIC
```{r}
  p.ord_psi. <-
    occu(
      ~ ord ~ 1,
      data = g.umf
    )

  p.ord2_psi. <-
    occu(
      ~ ord + I(ord)^2 ~ 1,
      data = g.umf
    )

  p.dtime_psi. <-
    occu(
      ~ dtime ~ 1,
      data = g.umf
    )

  p.dtime2_psi. <-
    occu(
      ~ dtime + I(dtime)^2 ~ 1,
      data = g.umf,
      starts = c(2, 2, 2, 2)
    )
  
    p.ord.dtime_psi. <-
    occu(
      ~ ord + dtime ~ 1,
      data = g.umf
    )

  p.ord.dtime2_psi. <-
    occu(
      ~ ord + dtime + I(dtime)^2 ~ 1,
      data = g.umf,
      starts = c(-2, -2, -2, 2, 2)
    )
  
  p.ord2.dtime_psi. <-
    occu(
      ~ ord + I(ord)^2 + dtime ~ 1,
      data = g.umf
    )
    
  p.ord2.dtime2_psi. <-
    occu(
      ~ ord + I(ord)^2 + dtime + I(dtime)^2 ~ 1,
      data = g.umf
    )
  
  AICcmodavg::aictab(
    list(
      p.ord_psi. = p.ord_psi.,
      p.ord2_psi. = p.ord2_psi.,
      p.dtime_psi. = p.dtime_psi.,
      p.dtime2_psi. = p.dtime2_psi.,
      p.ord.dtime_psi. = p.ord.dtime_psi.,
      p.ord2.dtime_psi. = p.ord2.dtime_psi.,
      p.ord2.dtime2_psi. = p.ord2.dtime2_psi.
      )
  )

#Model selection based on AICc:
#
#                   K    AICc Delta_AICc AICcWt Cum.Wt      LL
#p.ord.dtime_psi.   4 1150.90       0.00   0.60   0.60 -571.37
#p.ord2.dtime_psi.  5 1152.99       2.09   0.21   0.81 -571.37
#p.ord2.dtime2_psi. 6 1155.10       4.19   0.07   0.88 -571.37
#p.ord_psi.         3 1155.13       4.22   0.07   0.96 -574.51
#p.ord2_psi.        4 1157.19       6.29   0.03   0.98 -574.51
#p.dtime_psi.       3 1158.57       7.67   0.01   1.00 -576.24
#p.dtime2_psi.      4 1160.64       9.74   0.00   1.00 -576.24

```
# Evaluate mean vs. max openness models
```{r}
    p.ord.dtime_psi. <-
    occu(
      ~ ord + dtime ~ 1,
      data = g.umf
    )

    p.ord.dtime_psi.mean <-
    occu(
      ~ ord + dtime ~ mean,
      data = g.umf
    )

    p.ord.dtime_psi.max <-
    occu(
      ~ ord + dtime ~ max,
      data = g.umf
    )

    p.ord.dtime_psi.lmean <-
    occu(
      ~ ord + dtime ~ log(mean),
      data = g.umf
    )

    p.ord.dtime_psi.lmax <-
    occu(
      ~ ord + dtime ~ log(max),
      data = g.umf
    )

  AICcmodavg::aictab(
    list(
      p.ord.dtime_psi. = p.ord.dtime_psi.,
      p.ord.dtime_psi.mean = p.ord.dtime_psi.mean,
      p.ord.dtime_psi.max = p.ord.dtime_psi.max,
      p.ord.dtime_psi.lmean = p.ord.dtime_psi.lmean,
      p.ord.dtime_psi.lmax = p.ord.dtime_psi.lmax
      )
  )    

# Model selection based on AICc:
# 
#                       K    AICc Delta_AICc AICcWt Cum.Wt      LL
# p.ord.dtime_psi.max   5 1136.54       0.00   0.67   0.67 -563.14
# p.ord.dtime_psi.lmax  5 1139.13       2.58   0.18   0.86 -564.44
# p.ord.dtime_psi.mean  5 1140.51       3.97   0.09   0.95 -565.13
# p.ord.dtime_psi.lmean 5 1141.74       5.19   0.05   1.00 -565.74
# p.ord.dtime_psi.      4 1150.90      14.36   0.00   1.00 -571.37
```
# Grasshopper sparrow: Graph relationship with max 
```{r}
summary(p.ord.dtime_psi.max)

plotdata = data.frame(predict(p.ord.dtime_psi.max, newdata = data.frame(max = seq(6.8, 87, length.out = 100)), type = "state"),
                      max = data.frame(max = seq(6.8, 87, length.out = 100)))

ggplot(plotdata) +
   geom_ribbon(aes(x = max, ymin = lower, ymax = upper), alpha = 0.5) +
      geom_line(aes(x = max, y = Predicted), size = 1.5)
```

